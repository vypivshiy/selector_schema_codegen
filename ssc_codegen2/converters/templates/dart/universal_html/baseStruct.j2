// Auto generated code by ssc_gen
// WARNING: Any manual changes made to this file will be lost when this
// is run again. Do not edit this file unless you know what you are doing.

import 'dart:core';
import 'package:universal_html/html.dart' show Document, LIElement;
import 'package:universal_html/parsing.dart' as html;


class BaseParser {
  // TODO constructors for Element, Document objects
  // TODO better api code
  late final Document selector;

  BaseParser(String rawDocument) {
    selector = html.parseHtmlDocument(rawDocument);
  }

  BaseParser.fromDocument(Document document) {
    selector = document;
  }

  BaseParser.fromElement(LIElement element) {
    // not needed to control nullable
    selector = html.parseHtmlDocument(element.innerHtml as String);
  }

  parse() {
    mPreValidate(selector);
    return mRunParse();
  }

  mPreValidate(el){
    // pre validate entrypoint
    null;
  }

  mRunParse(){
    // start parser entrypoint
  }

  mPartDocument(el){
    // dart document to elements entrypoint
  }

  mCss(el, query){
    return el.querySelector(query);
  }

  mCssAll(el, query){
    return el.querySelectorAll(query);
  }

  mXpath(){
    throw UnimplementedError("Not supported");
  }

  mXpathAll(){
    throw UnimplementedError("Not supported");
  }

  mAttrText(el){
    return el.text;
  }

  mAttrTextAll(els){
    return els.map((e) => e.text).toList();
  }

  mAttrRaw(LIElement el){
    return el.innerHtml;
  }

  mAttrRawAll(els){
    return els.map((e) => e.innerHtml).toList();
  }

  mAttr(el, String name){
    return el.attributes[name];
  }

  mAttrAll(els, name){
    return els.map((e) => e.attributes[name]).toList();
  }

  mAssertEq(el, val, msg){
    assert(el == val, msg);
    return el;
  }

  mAssertContains(el, val, msg){
    assert(el != null && el.contains(val), msg);
    return el;
  }

  mAssertReMatch(el, val, msg){
    assert(el != null && RegExp(val).firstMatch(el) != null, msg);
    return el;
  }
  mAssertCss(el, query, msg){
    assert(el.querySelector(query) != null, msg);
    return el;
  }

  mAssertXpath(){
    throw UnimplementedError("Not supported");
  }

  mReMatch(String s, String pattern){
    return RegExp(pattern).firstMatch(s)?.group(0)!;
  }

  mReMatchAll(String s, String pattern){
    return RegExp(pattern).allMatches(s).map((e) => e.group(0)!).toList();
  }

  mReSub(String s, String pattern, String repl){
    return s.replaceAll(RegExp(pattern), repl);
  }

  mStrTrim(String s, String repl) {
    // https://stackoverflow.com/a/14107914
    var replLeft = "^$repl";
    var replRight = "$repl\$";
    return s
        .replaceFirst(RegExp(replLeft), "")
        .replaceFirst(RegExp(replRight), "");
  }

  mStrLTrim(String s, String repl) {
    var replLeft = "^$repl";
    return s.replaceFirst(RegExp(replLeft), "");
  }

  mStrRTrim(String s, String repl) {
    var replRight = "$repl\$";
    return s.replaceFirst(RegExp(replRight), "");
  }

  mStrReplace(String s, String repl, String replNew){
    return s.replaceAll(repl, replNew);
  }

  mStrFormat(String variable, String template){
    return template.replaceFirst({% raw %}"{{}}"{% endraw %}, variable);
  }

  mStrSplit(String variable, String sep){
    return variable.split(sep);
  }

  mArrIndex(variable, int index){
    return variable[index];
  }

  mArrJoin(variable, sep){
    return variable.join(sep);
  }

}