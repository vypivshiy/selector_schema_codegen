// Auto generated code by ssc_gen
// WARNING: Any manual changes made to this file will be lost when this
// is run again. Do not edit this file unless you know what you are doing.

import 'dart:core';
import 'package:universal_html/html.dart' show Document, LIElement;
import 'package:universal_html/parsing.dart' as html;


class BaseParser {
  // TODO constructors for Element, Document objects
  // TODO better api code
  late final Document selector;

  BaseParser(String raw_document) {
    selector = html.parseHtmlDocument(raw_document);
  }

  BaseParser.fromDocument(Document document) {
    selector = document;
  }

  BaseParser.fromElement(LIElement element) {
    // not needed to control nullable
    selector = html.parseHtmlDocument(element.innerHtml as String);
  }

  parse() {
    m_preValidate(selector);
    return m_runParse();
  }

  m_preValidate(el){
    // pre validate entrypoint
    null;
  }

  m_runParse(){
    // start parser entrypoint
  }

  m_partDocument(el){
    // dart document to elements entrypoint
  }

  m_parseNested(el, parserConstructor){
    // TODO add overload (extra constructors?)
    if (el is String){
      return parserConstructor(el).parse();
    }
    if (el is LIElement){
      return parserConstructor(el.outerHtml).parse();
    }

    if (el is Document){
      return parserConstructor(el.querySelector('html')?.outerHtml).parse();
    }
  }

  m_css(el, query){
    return el.querySelector(query);
  }

  m_cssAll(el, query){
    return el.querySelectorAll(query);
  }

  m_xpath(){
    throw UnimplementedError("Not supported");
  }

  m_xpathAll(){
    throw UnimplementedError("Not supported");
  }

  m_attrText(el){
    return el.text;
  }

  m_attrTextAll(els){
    return els.map((e) => e.text).toList();
  }

  m_attrRaw(LIElement el){
    return el.innerHtml;
  }

  m_attrRawAll(els){
    return els.map((e) => e.innerHtml).toList();
  }

  m_attr(el, String name){
    return el.attributes[name];
  }

  m_attrAll(els, name){
    return els.map((e) => e.attributes[name]).toList();
  }

  m_assertEq(el, val, msg){
    assert(el == val, msg);
    return el;
  }

  m_assertContains(el, val, msg){
    assert(el != null && el.contains(val), msg);
    return el;
  }

  m_assertReMatch(el, val, msg){
    assert(el != null && RegExp(val).firstMatch(el) != null, msg);
    return el;
  }
  m_assertCss(el, query, msg){
    assert(el.querySelector(query) != null, msg);
    return el;
  }

  m_assertXpath(){
    throw UnimplementedError("Not supported");
  }

  m_reMatch(String s, String pattern){
    return RegExp(pattern).firstMatch(s);
  }

  m_reMatchAll(String s, String pattern){
    return RegExp(pattern).allMatches(s).map((e) => e.group(0)!).toList();
  }

  m_reSub(String s, String pattern, String repl){
    return s.replaceAll(RegExp(pattern), repl);
  }

  m_strTrim(String s, String repl){
    // https://stackoverflow.com/a/14107914
    var replLeft = "^$repl";
    var replRight = "$repl\$";
    return s.replaceFirst(replLeft, "").replaceFirst(replRight, "");
  }

  m_strLTrim(String s, String repl){
    var replLeft = "^$repl";
    return s.replaceFirst(replLeft, "");
  }

  m_strRTrim(String s, String repl){
    var replRight = "$repl\$";
    return s.replaceFirst(replRight, "");
  }

  m_strReplace(String s, String repl, String replNew){
    return s.replaceAll(repl, replNew);
  }

  m_strFormat(String variable, String template){
    // mark \{\{\}\}
    // todo param placeholder
    return template.replaceFirst("\{\{\}\}", variable);
  }

  m_strSplit(String variable, String sep){
    return variable.split(sep);
  }

  m_arrIndex(variable, int index){
    return variable[index];
  }

  m_arrJoin(variable, sep){
    return variable.join(sep);
  }

}