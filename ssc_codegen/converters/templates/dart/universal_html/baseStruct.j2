// Auto generated code by ssc_gen
// WARNING: Any manual changes made to this file will be lost when this
// is run again. Do not edit this file unless you know what you are doing.

import 'dart:core';
import 'package:universal_html/html.dart' show Document, LIElement;
import 'package:universal_html/parsing.dart' as html;

class BaseParser {
  // TODO constructors for Element, Document objects
  // TODO rewrite cringe api
  late final Document selector;

  BaseParser(String rawDocument) {
    selector = html.parseHtmlDocument(rawDocument);
  }

  BaseParser.fromDocument(Document document) {
    selector = document;
  }

  BaseParser.fromElement(LIElement element) {
    // not needed to control nullable
    selector = html.parseHtmlDocument(element.innerHtml as String);
  }

  parse() {
    mPreValidate(selector);
    return mRunParse();
  }

  mPreValidate(el) {
    // pre validate entrypoint
    null;
  }

  mRunParse() {
    // start parser entrypoint
  }

  mPartDocument(Document el) {
    // dart document to elements entrypoint
  }

  mCss(el, String query) {
    return el.querySelector(query);
  }

  mCssAll(el, String query) {
    return el.querySelectorAll(query);
  }

  /// universal_html doesn't support xpath
  mXpath(el, query) {
    throw UnimplementedError("Not supported");
  }

  /// universal_html doesn't support xpath
  mXpathAll(el, query) {
    throw UnimplementedError("Not supported");
  }

  mAttrText(el) {
    return el.text;
  }

  mAttrTextAll(els) {
    return els.map((e) => e.text).toList();
  }

  mAttrRaw(el) {
    return el.innerHtml;
  }

  mAttrRawAll(els) {
    return els.map((e) => e.innerHtml).toList();
  }

  mAttr(el, String name) {
    return el.attributes[name];
  }

  mAttrAll(els, String name) {
    return els.map((e) => e.attributes[name]).toList();
  }

  mAssertEq(el, val, String msg) {
    assert(el == val, msg);
    return el;
  }

  mAssertContains(el, val, String msg) {
    assert(el != null && el.contains(val), msg);
    return el;
  }

  mAssertReMatch(el, val, String msg) {
    assert(el != null && RegExp(val).firstMatch(el) != null, msg);
    return el;
  }

  mAssertCss(el, String query, String msg) {
    assert(el.querySelector(query) != null, msg);
    return el;
  }

  mAssertXpath() {
    throw UnimplementedError("Not supported");
  }

  mReMatch(String s, String pattern, {int group = 1}) {
    return RegExp(pattern).firstMatch(s)?.group(group)!;
  }

  mReMatchAll(String s, String pattern, {int group = 1}) {
    return RegExp(pattern).allMatches(s).map((e) => e.group(group)!).toList();
  }

  mReSub(String s, String pattern, String repl) {
    return s.replaceAll(RegExp(pattern), repl);
  }

  mStrTrim(String s, String repl) {
    // https://stackoverflow.com/a/14107914
    var replLeft = "^$repl";
    var replRight = "$repl\$";
    return s
        .replaceFirst(RegExp(replLeft), "")
        .replaceFirst(RegExp(replRight), "");
  }

  mStrLTrim(String s, String repl) {
    var replLeft = "^$repl";
    return s.replaceFirst(RegExp(replLeft), "");
  }

  mStrRTrim(String s, String repl) {
    var replRight = "$repl\$";
    return s.replaceFirst(RegExp(replRight), "");
  }

  mStrReplace(String s, String repl, String replNew) {
    return s.replaceAll(repl, replNew);
  }

  mStrFormat(String variable, String template) {
    return template.replaceFirst({% raw %}"{{}}"{% endraw %}, variable);
  }

  mStrSplit(String variable, String sep) {
    return variable.split(sep);
  }

  mArrIndex(variable, int index) {
    return variable[index];
  }

  mArrJoin(variable, sep) {
    return variable.join(sep);
  }
}
