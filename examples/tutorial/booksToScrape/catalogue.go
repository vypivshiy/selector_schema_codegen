// autogenerated by ssc-gen DO NOT_EDIT
//

package main

import (
	"fmt"
	"github.com/PuerkitoBio/goquery"
	"regexp"
	"strings"
)

type TBook struct {
	Name     string  `json:"name"`
	ImageUrl string  `json:"image_url"`
	Url      string  `json:"url"`
	Rating   int     `json:"rating"`
	Price    float64 `json:"price"`
}
type TMainCatalogue struct {
	Books    []TBook `json:"books"`
	PrevPage *string `json:"prev_page"`
	NextPage *string `json:"next_page"`
	CurrPage string  `json:"curr_page"`
}

// Book Exctract a book cards
//
//	Usage:
//
//	    - GET https://books.toscrape.com/
//	    - GET https://books.toscrape.com/catalogue/page-2.html
//	    - GET https://books.toscrape.com/catalogue/page-50.html
//
// [
//
//	{
//	    "name": "String",
//	    "image_url": "String",
//	    "url": "String",
//	    "rating": "Int",
//	    "price": "Float"
//	},
//	"..."
//
// ]
type Book struct {
	Document *goquery.Document
}

func (p *Book) preValidate(v *goquery.Selection) (error, error) {
	err := sscAssertCss(v, ".col-lg-3 .thumbnail", "")
	if err != nil {
		return nil, err
	}
	return nil, nil
}
func (p *Book) splitDoc(v *goquery.Selection) (*goquery.Selection, error) {
	v0 := v.Find(".col-lg-3")
	return v0, nil
}
func (p *Book) parseName(v *goquery.Selection) (string, error) {
	v0 := v.Find(".thumbnail").First()
	v1, err := sscGetAttr(v0, "alt")
	if err != nil {
		return "", err
	}
	return v1, nil
}
func (p *Book) parseImageUrl(v *goquery.Selection) (string, error) {
	v0 := v.Find(".thumbnail").First()
	v1, err := sscGetAttr(v0, "src")
	if err != nil {
		return "", err
	}
	v2 := strings.TrimPrefix(v1, "..")
	v3 := strings.TrimLeft(v2, "/")
	v4 := fmt.Sprintf("https://books.toscrape.com/%s", v3)
	return v4, nil
}
func (p *Book) parseUrl(v *goquery.Selection) (string, error) {
	v0 := v.Find(".image_container > a").First()
	v1, err := sscGetAttr(v0, "href")
	if err != nil {
		return "", err
	}
	v2 := strings.TrimLeft(v1, "/")
	v3 := strings.TrimPrefix(v2, "catalogue/")
	v4 := fmt.Sprintf("https://books.toscrape.com/catalogue/%s", v3)
	return v4, nil
}
func (p *Book) parseRating(v *goquery.Selection) (result int, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = nil
			result = 0
		}
	}()
	v0 := v
	v1 := v0.Find(".star-rating").First()
	v2, err := sscGetAttr(v1, "class")
	if err != nil {
		panic(err)
	}
	v3 := strings.TrimPrefix(v2, "star-rating ")
	v4 := sscStringReplaceWithMap(v3, []string{"One", "1", "Two", "2", "Three", "3", "Four", "4", "Five", "5"})
	v5, err := sscStrToInt(v4)
	if err != nil {
		panic(err)
	}
	result = v5
	return result, nil
}
func (p *Book) parsePrice(v *goquery.Selection) (result float64, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = nil
			result = 0.0
		}
	}()
	v0 := v
	v1 := v0.Find(".price_color").First()
	v2 := v1.Text()
	v3, err := sscRegexMatch(v2, regexp.MustCompile(`(\d+(?:.\d+)?)`), 1)
	if err != nil {
		panic(err)
	}
	v4, err := sscStrToFloat(v3)
	if err != nil {
		panic(err)
	}
	result = v4
	return result, nil
}
func (p *Book) Parse() (*[]TBook, error) {

	items := make([]TBook, 0)
	docParts, err := p.splitDoc(p.Document.Selection)
	if err != nil {
		return nil, err
	}

	for _, i := range docParts.EachIter() {
		name, err := p.parseName(i)
		if err != nil {
			return nil, err
		}
		imageUrl, err := p.parseImageUrl(i)
		if err != nil {
			return nil, err
		}
		url, err := p.parseUrl(i)
		if err != nil {
			return nil, err
		}
		rating, err := p.parseRating(i)
		if err != nil {
			return nil, err
		}
		price, err := p.parsePrice(i)
		if err != nil {
			return nil, err
		}

		item := TBook{
			name, imageUrl, url, rating, price,
		}
		items = append(items, item)
	}
	return &items, nil
}

// MainCatalogue Extract pagination urls and book cards
//
//	Usage Examples:
//
//	    - GET https://books.toscrape.com/
//	    - GET https://books.toscrape.com/catalogue/page-2.html
//	    - GET https://books.toscrape.com/catalogue/page-50.html
//
//	Issues:
//	    - on the first page, prev_page = None
//	    - on the last page, next_page = None
//
//	{
//	    "books": [
//	        {
//	            "name": "String",
//	            "image_url": "String",
//	            "url": "String",
//	            "rating": "Int",
//	            "price": "Float"
//	        },
//	        "..."
//	    ],
//	    "prev_page": "String",
//	    "next_page": "String",
//	    "curr_page": "String"
//	}
type MainCatalogue struct {
	Document *goquery.Document
}

func (p *MainCatalogue) parseBooks(v *goquery.Selection) (*[]TBook, error) {
	v0Doc := goquery.NewDocumentFromNode(v.Nodes[0])
	v0St := Book{v0Doc}
	v0, err := v0St.Parse()
	if err != nil {
		return nil, err
	}
	return v0, nil
}
func (p *MainCatalogue) parsePrevPage(v *goquery.Selection) (result *string, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = nil
			result = nil
		}
	}()
	v0 := v
	v1 := v0.Find(".previous a").First()
	v2, err := sscGetAttr(v1, "href")
	if err != nil {
		panic(err)
	}
	v3 := strings.TrimPrefix(v2, "catalogue/")
	v4 := fmt.Sprintf("https://books.toscrape.com/catalogue/%s", v3)
	result = &v4
	return result, nil
}
func (p *MainCatalogue) parseNextPage(v *goquery.Selection) (result *string, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = nil
			result = nil
		}
	}()
	v0 := v
	v1 := v0.Find(".next a").First()
	v2, err := sscGetAttr(v1, "href")
	if err != nil {
		panic(err)
	}
	v3 := strings.TrimPrefix(v2, "catalogue/")
	v4 := fmt.Sprintf("https://books.toscrape.com/catalogue/%s", v3)
	result = &v4
	return result, nil
}
func (p *MainCatalogue) parseCurrPage(v *goquery.Selection) (string, error) {
	v0 := v.Find(".current").First()
	v1 := v0.Text()
	v2, err := sscRegexMatch(v1, regexp.MustCompile(`Page\s(\d+)`), 1)
	if err != nil {
		return "", err
	}
	v3 := fmt.Sprintf("https://books.toscrape.com/catalogue/page-%s.html", v2)
	return v3, nil
}
func (p *MainCatalogue) Parse() (*TMainCatalogue, error) {

	books, err := p.parseBooks(p.Document.Selection)
	if err != nil {
		return nil, err
	}
	prevPage, err := p.parsePrevPage(p.Document.Selection)
	if err != nil {
		return nil, err
	}
	nextPage, err := p.parseNextPage(p.Document.Selection)
	if err != nil {
		return nil, err
	}
	currPage, err := p.parseCurrPage(p.Document.Selection)
	if err != nil {
		return nil, err
	}

	item := TMainCatalogue{
		*books, prevPage, nextPage, currPage,
	}
	return &item, nil
}
