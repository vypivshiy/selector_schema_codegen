// autogenerated by ssc-gen DO NOT_EDIT
//

package main

import (
	"fmt"
	"github.com/PuerkitoBio/goquery"
	"regexp"
	"slices"
	"strconv"
	"strings"
)

var (
	sscHexEntityRe  = regexp.MustCompile(`&#x([0-9a-fA-F]+);`)
	sscUnicodeEscRe = regexp.MustCompile(`\\u([0-9a-fA-F]{4})`)
	sscByteEscRe    = regexp.MustCompile(`\\x([0-9a-fA-F]{2})`)
	sscCharEscRe    = regexp.MustCompile(`\\([bfnrt])`)
	sscCharEscMap   = map[byte]string{'b': "\b", 'f': "\f", 'n': "\n", 'r': "\r", 't': "\t"}
	sscHtmlUnescMap = map[string]string{"&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": "\"", "&#039;": "'", "&#x2F;": "/", "&nbsp;": " "}
)

func mapStr(vs []string, f func(string) string) []string {
	r := make([]string, len(vs))
	for i, s := range vs {
		r[i] = f(s)
	}
	return r
}

func sscSliceStrFmt(v []string, t string) []string {
	return mapStr(v, func(s string) string { return fmt.Sprintf(t, s) })
}
func sscSliceStrTrim(v []string, c string) []string {
	return mapStr(v, func(s string) string { return strings.Trim(s, c) })
}
func sscSliceStrLTrim(v []string, c string) []string {
	return mapStr(v, func(s string) string { return strings.TrimLeft(s, c) })
}
func sscSliceStrRTrim(v []string, c string) []string {
	return mapStr(v, func(s string) string { return strings.TrimRight(s, c) })
}
func sscSliceStrRmPrefix(v []string, p string) []string {
	return mapStr(v, func(s string) string { return strings.TrimPrefix(s, p) })
}
func sscSliceStrRmSuffix(v []string, s string) []string {
	return mapStr(v, func(str string) string { return strings.TrimSuffix(str, s) })
}
func sscSliceStrReplace(v []string, o, n string) []string {
	return mapStr(v, func(s string) string { return strings.ReplaceAll(s, o, n) })
}

func sscSliceStrRmPrefixSuffix(v []string, p, s string) []string {
	return mapStr(v, func(str string) string { return strings.TrimSuffix(strings.TrimPrefix(str, p), s) })
}

func sscSliceStrReSub(v []string, re *regexp.Regexp, repl string) []string {

	return mapStr(v, func(s string) string { return re.ReplaceAllString(s, repl) })
}

func sscRegexMatch(v string, re *regexp.Regexp, g int) (string, error) {
	m := re.FindStringSubmatch(v)
	if m == nil {
		return "", fmt.Errorf("not found match %v", re)
	}
	return m[g], nil
}

func sscRegexFindAll(v string, re *regexp.Regexp) ([]string, error) {
	m := re.FindAllString(v, -1)
	if m == nil {
		return nil, fmt.Errorf("not found match %v", re)
	}
	return m, nil
}

func sscSliceStrToSliceInt(v []string) ([]int, error) {
	r := make([]int, 0, len(v))
	for _, s := range v {
		if i, err := strconv.Atoi(s); err != nil {
			return nil, err
		} else {
			r = append(r, i)
		}
	}
	return r, nil
}

func sscSliceStrToSliceFloat(v []string) ([]float64, error) {
	r := make([]float64, 0, len(v))
	for _, s := range v {
		if f, err := strconv.ParseFloat(s, 64); err != nil {
			return nil, err
		} else {
			r = append(r, f)
		}
	}
	return r, nil
}

func sscStrToInt(v string) (int, error)       { return strconv.Atoi(v) }
func sscStrToFloat(v string) (float64, error) { return strconv.ParseFloat(v, 64) }

func sscGetAttr(a *goquery.Selection, key string) (string, error) {
	if attr, ok := a.Attr(key); ok {
		return attr, nil
	}
	return "", fmt.Errorf("attr `%s` not exists", key)
}

func sscEachGetAttrs(a *goquery.Selection, key string) ([]string, error) {
	var r []string
	var err error
	a.Each(func(_ int, s *goquery.Selection) {
		if attr, ok := s.Attr(key); ok {
			r = append(r, attr)
		} else if err == nil {
			err = fmt.Errorf("attr `%s` not exists", key)
		}
	})
	return r, err
}

func sscGetManyAttrs(a *goquery.Selection, keys []string) []string {
	keys = []string{"a", "b", "c"}
	var r []string
	for _, k := range keys {
		if attr, ok := a.Attr(k); ok {
			r = append(r, attr)
		}
	}
	return r
}

func sscEachGetManyAttrs(a *goquery.Selection, keys []string) []string {
	var r []string
	a.Each(func(_ int, s *goquery.Selection) {
		for _, k := range keys {
			if attr, ok := s.Attr(k); ok {
				r = append(r, attr)
			}
		}
	})
	return r
}

func sscEachGetText(a *goquery.Selection) []string {
	var r []string
	a.Each(func(_ int, s *goquery.Selection) {
		r = append(r, s.Text())
	})
	return r
}

func sscUnescape(s string) string {
	s = strings.NewReplacer(
		"&amp;", "&", "&lt;", "<", "&gt;", ">", "&quot;", "\"",
		"&#039;", "'", "&#x2F;", "/", "&nbsp;", " ",
	).Replace(s)

	s = sscHexEntityRe.ReplaceAllStringFunc(s, func(m string) string {
		if i, err := strconv.ParseInt(sscHexEntityRe.FindStringSubmatch(m)[1], 16, 64); err == nil {
			return string(rune(i))
		}
		return m
	})

	s = sscUnicodeEscRe.ReplaceAllStringFunc(s, func(m string) string {
		if i, err := strconv.ParseUint(sscUnicodeEscRe.FindStringSubmatch(m)[1], 16, 16); err == nil {
			return string(rune(i))
		}
		return m
	})

	s = sscByteEscRe.ReplaceAllStringFunc(s, func(m string) string {
		if i, err := strconv.ParseUint(sscByteEscRe.FindStringSubmatch(m)[1], 16, 8); err == nil {
			return string(byte(i))
		}
		return m
	})

	return sscCharEscRe.ReplaceAllStringFunc(s, func(m string) string {
		if repl, ok := sscCharEscMap[m[1]]; ok {
			return repl
		}
		return m
	})
}

func sscHtmlRawAll(a *goquery.Selection) ([]string, error) {
	var r []string
	var e error
	a.Each(func(_ int, s *goquery.Selection) {
		v, err := s.Html()
		if err != nil {
			e = err
			return
		}
		r = append(r, v)
	})
	if e != nil {
		return nil, e
	}
	return r, nil
}

func sscSliceUnescape(s []string) []string { return mapStr(s, sscUnescape) }

func sscAssertEqual[T comparable](v1, v2 T, msg string) error {
	if v1 != v2 {
		return fmt.Errorf(msg)
	}
	return nil
}

func sscAssertNotEqual[T comparable](v1, v2 T, msg string) error {
	if v1 == v2 {
		return fmt.Errorf(msg)
	}
	return nil
}

func sscAssertContains[S ~[]E, E comparable](v1 S, v2 E, msg string) error {
	if !(slices.Contains(v1, v2)) {
		return fmt.Errorf("%s", msg)
	}
	return nil
}

func sscAssertRegex(v string, re *regexp.Regexp, msg string) error {
	if !re.MatchString(v) {
		return fmt.Errorf(msg)
	}
	return nil
}

func sscAssertSliceAnyRegex(v []string, re *regexp.Regexp, msg string) error {
	for _, s := range v {
		if re.MatchString(s) {
			return nil
		}
	}
	return fmt.Errorf(msg)
}

func sscAssertSliceAllRegex(v []string, re *regexp.Regexp, msg string) error {
	for _, s := range v {
		if !re.MatchString(s) {
			return fmt.Errorf(msg)
		}
	}
	return nil
}

func sscAssertCss(v *goquery.Selection, query, msg string) error {
	found := false
	v.Find(query).EachWithBreak(func(_ int, _ *goquery.Selection) bool {
		found = true
		return false
	})
	if !found {
		return fmt.Errorf(msg)
	}
	return nil
}

func sscAssertHasAttr(v *goquery.Selection, key, msg string) error {
	if _, ok := v.Attr(key); !ok {
		return fmt.Errorf(msg)
	}
	return nil
}

func sscSliceStrUnique(v []string) []string {
	seen := make(map[string]bool, len(v))
	var r []string
	for _, s := range v {
		if !seen[s] {
			seen[s] = true
			r = append(r, s)
		}
	}
	return r
}

func sscStringReplaceWithMap(v string, p []string) string {
	return strings.NewReplacer(p...).Replace(v)
}

func sscSliceStringReplaceWithMap(v []string, p []string) []string {
	return mapStr(v, func(s string) string { return sscStringReplaceWithMap(s, p) })
}

func sscSliceStringFilter(v []string, f func(string) bool) []string {
	var r []string
	for _, s := range v {

		if f(s) {
			r = append(r, s)
		}
	}
	return r
}

func sscAnyStr(t []string, f func(string) bool) bool {
	for _, i := range t {
		if f(i) {
			return true
		}
	}
	return false
}

func sscAnyContainsSubstring(t string, s []string) bool {
	return sscAnyStr(s, func(s string) bool { return strings.Contains(t, s) })
}

func sscAnyStarts(t string, s []string) bool {
	return sscAnyStr(s, func(s string) bool { return strings.HasPrefix(t, s) })
}

func sscAnyEnds(t string, s []string) bool {
	return sscAnyStr(s, func(s string) bool { return strings.HasSuffix(t, s) })
}

func sscAnyEqual(t string, s []string) bool {
	return sscAnyStr(s, func(s string) bool { return t == s })
}

func sscAnyNotEqual(t string, s []string) bool {
	return sscAnyStr(s, func(s string) bool { return t != s })
}

func sscMapAttrs(a *goquery.Selection) []string {
	var r []string
	a.Each(func(_ int, s *goquery.Selection) {
		// parent node extract only
		for _, attr := range s.Nodes[0].Attr {
			r = append(r, attr.Val)
		}
	})
	return r
}

type TProductDescription = map[string]string

// ProductDescription parse product description from product page
//
//	USAGE:
//	    - GET https://books.toscrape.com/catalogue/in-her-wake_980/index.html
//	    - from catalogue page send GET request by key []books['url']
//
//	{
//	    "UPC": "String",
//	    "Product Type": "Books",
//	    "Price (excl. tax)": "String",
//	    "Price (incl. tax)": "String",
//	    "Tax": "String",
//	    "Availability": "In stock (<count>)",
//	    "Number of reviews": "0 (always, its fiction shop lol)"
//	}
type ProductDescription struct {
	Document *goquery.Document
}

func (p *ProductDescription) splitDoc(v *goquery.Selection) (*goquery.Selection, error) {
	v0 := v.Find("table tr")
	return v0, nil
}
func (p *ProductDescription) parseKey(v *goquery.Selection) (string, error) {
	v0 := v.Find("th").First()
	v1 := v0.Text()
	return v1, nil
}
func (p *ProductDescription) parseValue(v *goquery.Selection) (string, error) {
	v0 := v.Find("td").First()
	v1 := v0.Text()
	return v1, nil
}
func (p *ProductDescription) Parse() (*TProductDescription, error) {

	items := make(TProductDescription)
	docParts, err := p.splitDoc(p.Document.Selection)
	if err != nil {
		return nil, err
	}

	for _, i := range docParts.EachIter() {
		key, err := p.parseKey(i)
		if err != nil {
			return nil, err
		}

		value, err := p.parseValue(i)
		if err != nil {
			return nil, err
		}

		items[key] = value
	}

	return &items, nil
}
