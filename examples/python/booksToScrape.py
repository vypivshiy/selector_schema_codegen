# autogenerated by ssc-gen DO NOT_EDIT
"""Dummy parser config for http://books.toscrape.com/"""

from __future__ import annotations
import re
from typing import List, Dict, TypedDict, Union
from contextlib import suppress

from parsel import Selector, SelectorList

T_Urls = List[str]
T_UrlsMap = Dict[str, str]
T_Books_ITEM = TypedDict(
    "T_Books_ITEM",
    {"name": str, "image_url": str, "url": str, "rating": str, "price": int},
)
T_Books = List[T_Books_ITEM]
T_CataloguePage = TypedDict(
    "T_CataloguePage",
    {"title": str, "urls": T_Urls, "urls_map": T_UrlsMap, "books": T_Books},
)


class Urls:
    """fetch add patches and urls from <a> tag

    [
        "String",
        "..."
    ]"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = (
            Selector(document) if isinstance(document, str) else document
        )

    def _split_doc(self, value: Selector) -> SelectorList:
        value1 = value.css("a")
        return value1

    def _parse_item(self, value: Selector) -> str:
        value1 = value.css("::attr(href)").get()
        return value1

    def parse(self) -> T_Urls:
        return [self._parse_item(e) for e in self._split_doc(self._doc)]


class UrlsMap:
    """

    {
        "<K>": "String",
        "<KN>": "..."
    }"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = (
            Selector(document) if isinstance(document, str) else document
        )

    def _split_doc(self, value: Selector) -> SelectorList:
        value1 = value.css("a")
        return value1

    def _parse_key(self, value: Selector) -> str:
        value1 = value.css("::attr(href)").get()
        return value1

    def _parse_value(self, value: Selector) -> str:
        value1 = value.get()
        value2 = value1.strip(" ")
        return value2

    def parse(self) -> T_UrlsMap:
        return {
            self._parse_key(e): self._parse_value(e)
            for e in self._split_doc(self._doc)
        }


class Books:
    """

    [
        {
            "name": "String",
            "image_url": "String",
            "url": "String",
            "rating": "String",
            "price": "Int"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = (
            Selector(document) if isinstance(document, str) else document
        )

    def _split_doc(self, value: Selector) -> SelectorList:
        value1 = value.css(".col-lg-3")
        return value1

    def _parse_name(self, value: Selector) -> str:
        value1 = value.css(".thumbnail")
        value2 = value1.css("::attr(alt)").get()
        return value2

    def _parse_image_url(self, value: Selector) -> str:
        value1 = value.css(".thumbnail")
        value2 = value1.css("::attr(src)").get()
        value3 = "https://{}".format(value2) if value2 else value2
        return value3

    def _parse_url(self, value: Selector) -> str:
        value1 = value.css(".image_container > a")
        value2 = value1.css("::attr(href)").get()
        return value2

    def _parse_rating(self, value: Selector) -> str:
        value1 = value.css(".star-rating")
        value2 = value1.css("::attr(class)").get()
        value3 = value2.lstrip("star-rating ")
        return value3

    def _parse_price(self, value: Selector) -> int:
        value1 = value
        with suppress(Exception):
            value2 = value1.css(".price_color")
            value3 = value2.css("::text").get()
            value4 = re.search("(\\d+)", value3)[1]
            value5 = int(value4)
            return value5
        return 0

    def parse(self) -> List[T_Books]:
        return [
            {
                "name": self._parse_name(e),
                "image_url": self._parse_image_url(e),
                "url": self._parse_url(e),
                "rating": self._parse_rating(e),
                "price": self._parse_price(e),
            }
            for e in self._split_doc(self._doc)
        ]


class CataloguePage:
    """books.toscrape.com catalogue page entrypoint parser

        USAGE:

            1. GET <catalog page> (https://books.toscrape.com/, https://books.toscrape.com/catalogue/page-2.html, ...)
            2. add another prepare instruction how to correct cook page (if needed?)

        ISSUES:

            1. nope! Their love being scraped!


    {
        "title": "String",
        "urls": [
            "String",
            "..."
        ],
        "urls_map": {
            "<K>": "String",
            "<KN>": "..."
        },
        "books": [
            {
                "name": "String",
                "image_url": "String",
                "url": "String",
                "rating": "String",
                "price": "Any"
            },
            "..."
        ]
    }"""

    def __init__(self, document: Union[str, SelectorList, Selector]) -> None:
        self._doc = (
            Selector(document) if isinstance(document, str) else document
        )

    def _pre_validate(self, value: Union[Selector, SelectorList]) -> None:
        value1 = value.css("title")
        value2 = value1.css("::text").get()
        assert re.search("Books to Scrape", value2), ""
        return

    def _parse_title(self, value: Selector) -> str:
        value1 = value
        with suppress(Exception):
            assert value1.css("title"), ""
            value2 = value1
            value3 = value2.css("title")
            value4 = value3.css("::text").get()
            value5 = re.sub("^\\s+", "", value4)
            value6 = re.sub("\\s+$", "", value5)
            return value6
        return "test"

    def _parse_urls(self, value: Selector) -> T_Urls:
        value1 = Urls(value).parse()
        return value1

    def _parse_urls_map(self, value: Selector) -> T_UrlsMap:
        value1 = UrlsMap(value).parse()
        return value1

    def _parse_books(self, value: Selector) -> List[T_Books]:
        value1 = Books(value).parse()
        return value1

    def parse(self) -> T_CataloguePage:
        self._pre_validate(self._doc)
        return {
            "title": self._parse_title(self._doc),
            "urls": self._parse_urls(self._doc),
            "urls_map": self._parse_urls_map(self._doc),
            "books": self._parse_books(self._doc),
        }
