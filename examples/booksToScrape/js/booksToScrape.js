// autogenerated by ssc-gen DO NOT_EDIT
/**
 * Dummy parser config for http://books.toscrape.com/
 */
/**
 * fetch add patches and urls from <a> tag
 *
 * [
 *     "String",
 *     "..."
 * ]
 */
class Urls {
    constructor(doc) {
        if (typeof doc === 'string') {
            this._doc = new DOMParser().parseFromString(doc, 'text/html');
        } else if (doc instanceof Document || doc instanceof Element) {
            this._doc = doc;
        } else {
            throw new Error("Invalid input: Expected a Document, Element, or string");
        }
    }

    _splitDoc(value) {
        return Array.from(value.querySelectorAll('a'));
    }

    _parseItem(value) {
        return value.getAttribute('href');
    }

    parse() {
        return Array.from(this._splitDoc(this._doc)).map((e) => this._parseItem(e));
    }
}

/**
 *
 *
 * {
 *     "<K>": "String",
 *     "<KN>": "..."
 * }
 */
class UrlsMap {
    constructor(doc) {
        if (typeof doc === 'string') {
            this._doc = new DOMParser().parseFromString(doc, 'text/html');
        } else if (doc instanceof Document || doc instanceof Element) {
            this._doc = doc;
        } else {
            throw new Error("Invalid input: Expected a Document, Element, or string");
        }
    }

    _splitDoc(value) {
        return Array.from(value.querySelectorAll('a'));
    }

    _parseKey(value) {
        return value.getAttribute('href');
    }

    _parseValue(value) {
        let value1 = typeof value.outerHTML === "undefined" ? value.documentElement.outerHTML : value.outerHTML;
        return (function (str, chars) {
            return str.replace(new RegExp(`^[${chars}]+|[${chars}]+$`, 'g'), '');
        })(value1, ' ');
    }

    parse() {
        return Array.from(this._splitDoc(this._doc)).reduce((item, e) => (item[this._parseKey(e)] = this._parseValue(e), item), {});
    }
}

/**
 *
 *
 * [
 *     {
 *         "name": "String",
 *         "image_url": "String",
 *         "url": "String",
 *         "rating": "String",
 *         "price": "Int"
 *     },
 *     "..."
 * ]
 */
class Books {
    constructor(doc) {
        if (typeof doc === 'string') {
            this._doc = new DOMParser().parseFromString(doc, 'text/html');
        } else if (doc instanceof Document || doc instanceof Element) {
            this._doc = doc;
        } else {
            throw new Error("Invalid input: Expected a Document, Element, or string");
        }
    }

    _splitDoc(value) {
        return Array.from(value.querySelectorAll('.col-lg-3'));
    }

    _parseName(value) {
        let value1 = value.querySelector('.thumbnail');
        return value1.getAttribute('alt');
    }

    _parseImageUrl(value) {
        let value1 = value.querySelector('.thumbnail');
        let value2 = value1.getAttribute('src');
        return `https://${value2}`;
    }

    _parseUrl(value) {
        let value1 = value.querySelector('.image_container > a');
        return value1.getAttribute('href');
    }

    _parseRating(value) {
        let value1 = value.querySelector('.star-rating');
        let value2 = value1.getAttribute('class');
        return (function (str, chars) {
            return str.replace(new RegExp(`^[${chars}]+`, 'g'), '');
        })(value2, 'star-rating ');
    }

    _parsePrice(value) {
        try {
            let value1 = value;
            let value2 = value1.querySelector('.price_color');
            let value3 = typeof value2.textContent === "undefined" ? value2.documentElement.textContent : value2.textContent;
            let value4 = (new RegExp(/(\d+)/g)).exec(value3)[1];
            return parseInt(value4, 10);
        } catch (Error) {
            return 0;
        }
    }

    parse() {
        return Array.from(this._splitDoc(this._doc)).map(e => ({
            name: this._parseName(e),
            image_url: this._parseImageUrl(e),
            url: this._parseUrl(e),
            rating: this._parseRating(e),
            price: this._parsePrice(e)
        }));
    }
}

/**
 * books.toscrape.com catalogue page entrypoint parser
 *
 * USAGE:
 *
 *     1. GET <catalog page> (https://books.toscrape.com/, https://books.toscrape.com/catalogue/page-2.html, ...)
 *     2. add another prepare instruction how to correct cook page (if needed?)
 *
 * ISSUES:
 *
 *     1. nope! Their love being scraped!
 *
 *
 * {
 *     "title": "String",
 *     "urls": [
 *         "String",
 *         "..."
 *     ],
 *     "urls_map": {
 *         "<K>": "String",
 *         "<KN>": "..."
 *     },
 *     "books": [
 *         {
 *             "name": "String",
 *             "image_url": "String",
 *             "url": "String",
 *             "rating": "String",
 *             "price": "Int"
 *         },
 *         "..."
 *     ]
 * }
 */
class CataloguePage {
    constructor(doc) {
        if (typeof doc === 'string') {
            this._doc = new DOMParser().parseFromString(doc, 'text/html');
        } else if (doc instanceof Document || doc instanceof Element) {
            this._doc = doc;
        } else {
            throw new Error("Invalid input: Expected a Document, Element, or string");
        }
    }

    _preValidate(value) {
        let value1 = value.querySelector('title');
        let value2 = typeof value1.textContent === "undefined" ? value1.documentElement.textContent : value1.textContent;
        if (value2.match(/Books to Scrape/) === null) throw new Error('');
        return null;
    }

    _parseTitle(value) {
        try {
            let value1 = value;
            if (!value1.querySelector('title')) throw new Error('');
            let value2 = value1;
            let value3 = value2.querySelector('title');
            let value4 = typeof value3.textContent === "undefined" ? value3.documentElement.textContent : value3.textContent;
            let value5 = value4.replace(/^\s+/g, '');
            return value5.replace(/\s+$/g, '');
        } catch (Error) {
            return 'test';
        }
    }

    _parseUrls(value) {
        return (new Urls(value)).parse();
    }

    _parseUrlsMap(value) {
        return (new UrlsMap(value)).parse();
    }

    _parseBooks(value) {
        return (new Books(value)).parse();
    }

    parse() {
        this._preValidate(this._doc);
        return {
            title: this._parseTitle(this._doc),
            urls: this._parseUrls(this._doc),
            urls_map: this._parseUrlsMap(this._doc),
            books: this._parseBooks(this._doc)
        };
    }
}